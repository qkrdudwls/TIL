# Consistency
## Update Consistency
* 둘 이상의 사용자가 동일한 데이터를 동시에 쓰려고 할 때 발생하는 **쓰기-쓰기 충돌(write-write conflict)** 발생
* 업데이트가 서버에 도달하면, 서버는 이를 직렬화하여 하나의 업데이트를 먼저 적용한 후 다른 업데이트를 적용하기 때문에 초기의 업데이트는 사라진 업데이트가 될 수 있다.
### 동시성에 직면하여 일관성을 유지하는 방법
* **비관적 접근 방식**
    * 충돌이 발생하지 않도록 방지하는 방식
    * **Write locks**를 사용한다. 값을 변경하기 위해서는 lock을 획득해야 하고, 시스템은 한 번에 한 클라이언트만 lock을 획득할 수 있도록 보장한다.
    * 비관적 접근 방식은 종종 시스템의 반응성을 심각하게 낮추어 목적에 부적합하게 만든다.
* **낙관적 접근 방식**
    * 충돌이 발생하도록 허용하되 이를 감지하고 해결하는 방식
    1. **조건부 업데이트**. 모든 클라이언트가 업데이트를 수행하기 전에 마지막으로 읽은 값이 변경되었는지 확인하고, 변경되었다면 오류가 발생한다.
    2. 두 업데이트를 모두 저장하고 충돌 상태로 기록한다.
        * 주로 버전 제어 시스템에서 이루어지는 방식으로, 두 업데이트를 어떻게든 병합해야 하기 때문에 사용자가 두 값을 보고 해결하도록 한다. 
* 비관적 접근 방식과 낙관적 접근 방식은 모두 **업데이트의 일관된 직렬화**에 의존한다. 서버가 여러 대인 경우(동료 간 복제가 있는 경우), **순차적 일관성(Sequential Consistency)** 를 보장한다.
* 복제는 쓰기-쓰기 충돌의 발생 가능성을 더 높인다. 일부 데이터에 대해 모든 쓰기의 대상이 되는 단일 데이터를 사용하는 것이 업데이트 일관성을 유지하는 데 훨씬 더 쉽기 때문에 P2P replication을 제외한 모든 모델이 이를 수행한다.
## Read Consistency
* 데이터베이스는 사용자들로부터 항상 일관된 응답을 받지 않기 때문에 **일관되지 않은 읽기(Inconsistent Read)** 또는 **읽기-쓰기 충돌(read-write conflict)** 이 발생할 수 있다.
### 논리적 일관성
* 데이터의 상태나 값들이 시스템 내에서 논리적으로 일관된 상태를 유지하는 것을 논리적 일관성(Logical Consistency)라고 한다. 
* 관계형 데이터베이스는 **트랜잭션** 개념을 지원하여 논리적으로 일관되지 않은 읽기-쓰기 충돌을 피한다.
* Aggregate 지향 데이터베이스는 트랜잭션이 없는 반면, **그래프 데이터베이스**는 관계형 데이터베이스와 같이 ACID 트랜잭션을 지원한다.
* Aggregate 지향 데이터베이스는 단일 집합 내에서만 atomic 업데이트를 지원하는데, 이는 aggregate 내에서 논리적 일관성을 가지지만, aggregate 간에는 그렇지 않다. 
* 불일치가 존재하는 시간을 **불일치 윈도우(Inconsistency Window**라고 한다.
### 복제 일관성
* 데이터가 여러 노드에 복제될 때, 데이터의 일관성을 유지하는 정도를 복제 일관성으로, 복제된 데이터가 언제, 어떻게 동기화되고 일관성을 보장할 것인지에 대한 정책과 메커니즘을 의미한다.
* 복제는 불일치 윈도우를 길게 하여 논리적 불일치를 악화시킨다.
* 개별 요청에 대해 원하는 일관성 수준을 지정할 수 있는데, 문제가 되지 않을 때는 **약한 일관성(Weak Consistency)** 을 사용하고, 필요할 때 **강한 일관성(Strong Consistency)** 을 요청할 수 있다.
    * **약한 일관성**: 데이터가 언제 일관된 상태가 될 지에 대해 보장하지 않기 때문에 데이터 업데이트는 즉시 다른 노드에 반영되지 않을 수 있다.
        * **장점**: 매우 높은 가용성과 빠른 응답성을 제공한다.
        * **단점**: 데이터 불일치가 빈번하게 발생할 수 있으며, 일관성에 대한 신뢰도가 낮다.
    * **강한 일관성**: 모든 노드가 항상 동일한 데이터 상태를 가지는 것을 보장하기 때문에 어떤 노드에서 읽더라도 항상 최신 데이터가 보장된다.
        * **장점**: 데이터 일관성이 높아 응용 프로그램에서 일관된 결과를 얻을 수 있다.
        * **단점**: 모든 노드가 동기화되어야 하므로, 지연(latency)이 증가하고 가용성이 낮아질 수 있다. 
* 불일치 윈도우의 존재는 자신과의 불일치가 발생하면 큰 문제가 될 수 있기 때문에 자신의 쓰기를 읽는 일관성(read-your-writes consistency)가 필요하다.
### 세션 일관성
* 일반적으로 일관성이 계속 유지되는 시스템에서 자신의 쓰기를 읽는 일관성을 얻는 한 가지 방법은 **세션 일관성(Session Consistency)** 을 제공하는 것이다.
* 세션 일관성을 제공하는 방법으로는 **스티키 세션(Sticky Session)** 과 **버전 스탬프(Version Stamp)** 가 있다.
#### 스티키 세션
* 스티키 세션은 로드 밸런서(Load Balancer)나 분산 시스템에서 클라이언트의 요청을 동일한 서버로 계속 라우팅하도록 하는 방법으로, 세션 상태를 서버에서 관리하는 경우 유용하다.
* **작동 원리**
    * **세션 라우팅**: 클라이언트가 서버에 첫 번째 요청을 보내면, 로드 밸런서는 클라이언트의 요청을 특정 서버에 전달한다. 이후 로드 밸런서는 클라이언트의 세션 정보를 기반으로 해당 클라이언트의 모든 요청을 같은 서버로 라우팅한다.
    * **세션 유지**: 서버는 클라이언트의 세션 상태를 유지하고, 세션 관련 데이터는 서버의 메모리나 저장소에 저장된다. 클라이언트가 계속해서 서버에 요청을 보내므로, 서버는 이전 요청의 상태를 계속 유지할 수 있다.
* **장점**
    * **상태 유지**: 클라이언트의 상태나 세션 정보가 서버에 저장되기 때문에 세션 상태를 쉽게 유지할 수 있다.
    * **성능 향상**: 세션 정보를 반복적으로 조회할 필요가 없어, 요청 처리가 더 빠를 수 있다. 
* **단점**
    * **서버 장애**: 특정 서버가 다운되면 해당 서버에 저장딘 세션 정보가 손실될 수 있다. 이 경우, 세션 복구가 어려울 수 있다.
    * **로드 밸런싱**: 클라이언트가 항상 동일한 서버로 라우팅되므로, 로드 밸런싱이 비효율적일 수 있다.
#### 버전 스탬프
* 버전 스탬프는 데이터의 버전을 추적하여 동시성 문제를 해결하는 기술로, 데이터의 변경 이력을 저장하고, 데이터의 일관성을 유지하는 데 도움이 된다.
* **작동 원리**
    * **버전 관리**: 데이터 항목에 버전 번호나 스탬프를 부여하여, 각 데이터의 버전을 명확히 구분한다. 이 버전 번호는 데이터가 수정될 때마다 증가한다.
    * **충돌 감지**: 데이터에 대한 읽기와 쓰기 연산이 발생할 때, 현재 데이터의 버전과 클라이언트가 가지고 있는 버전을 비교하여 충돌 여부를 판단한다.
    * **쓰기 연산**: 데이터 업데이트 요청이 있을 때, 클라이언트는 현재 데이터의 버전 스탬프를 포함하여 업데이트를 요청한다. 서버는 클라이언트가 제공한 버전 스탬픙가 현재 데이터의 버전과 일치하는지 확인하여 일치하면 업데이트를 적용하고, 그렇지 않으면 충돌을 감지하고 적절한 처리를 수행한다.
* **장점**
    * **충돌 해결**: 데이터의 버전 정보를 통해 동시성 문제를 해결할 수 있다. 충돌 발생 시 이를 감지하고 적절한 조치를 취할 수 있다.
    * **일관성 보장**: 데이터의 최신 상태를 보장하고, 데이터 업데이트가 일관되도록 관리할 수 있다.
* **단점**
    * **복잡성**: 버전 관리와 충돌 해결 로직이 추가되어 구현과 관리에 복잡할 수 있다.
    * **성능**: 버전 검사를 통해 충돌을 감지하고 처리해야 하므로, 성능에 영향을 미칠 수 있다. 
## Relaxing Consistency
* 시스템에서 불일치를 피하도록 설계하는 것은 가능하지만, 시스템의 다른 특성들을 고려했을 때 불가능한 경우가 종종 있다.
* 일관성 희생은 시스템 설계에 필연적으로 수반되는 타협의 일환으로 작용한다. 
### The CAP Theorem
* **CAP 정리**는 분산 시스템의 설계에서 중요한 세 가지 특성인 **일관성(Consistency)**, **가용성(Availability)**, **분할 내성(Partiton Tolerance)** 사이의 tradeoff를 설명하는 정리이다. 
#### 일관성 (Consistency)
* 모든 노드에서 동일한 시점의 데이터를 볼 수 있어야 한다는 것을 의미한다. 즉, 어떤 노드에서 읽거나 쓴 데이터는 즉시 모든 다른 노드에 반영되어야 한다.
#### 가용성 (Availability)
* 시스템의 일부 노드가 실패하더라도, 모든 요청에 대해 항상 응답을 할 수 있어야 한다는 것을 의미한다. 즉, 노드가 다운되지 않는 한, 클라이언트의 모든 요청은 반드시 응답을 받아야 한다.
#### 분할 내성 (Partiton Tolerance)
* 네트워크 분할이 발생해도 시스템이 정상적으로 동작해야 한다는 것을 의미한다. 네트워크 분할이란 노드들 간의 통신이 불가능한 상황을 말한다. 
#### CAP 정리의 핵심 주장
* 위의 세 가지 특성을 동시에 만족시킬 수 없으며, 분산 시스템에서는 오직 두 가지 특성만을 선택할 수 있다.
##### 세 가지 선택 가능 조합
1. **CA (Consistency and Availability)**
    * 일관성과 가용성을 만족하지만, 분할 내성은 포기한다.
    * 단일 노드 데이터베이스 시스템은 네트워크 분할이 없으므로 CA 시스템으로 볼 수 있다.
    * 단일 서버 데이터베이스, 대부분의 전통적인 관계형 데이터베이스(RDBMS).
2. **CP (Consistency and Partiton Tolerance)**
    * 일관성과 분할 내성을 만족하지만, 가용성은 포기한다.
    * 네트워크 분할 시 일관성을 유지하기 위해 일부 노드는 응답하지 않을 수 있다. 이는 데이터의 일관성을 보장하기 위해 가용성을 희생하는 것이다.
    * 금융 거래 시스템 
3. **AP (Availability and Partiton Tolerance)**
    * 가용성과 분할 내성을 만족하지만, 일관성은 포기한다.
    * 네트워크 분할 시 모든 요청에 대해 응답할 수 있지만, 데이터의 일관성을 보장할 수는 없다. 
    * 분산 캐시 시스템, 소셜 미디어 피드. 
## Relaxing Durability
* 성능을 높이기 위해 일부 **영속성을 tradeoff**하는 경우가 있다.
* 데이터베이스가 메모리에서 실행되고, 업데이트를 in-memory representation에 적용하며, 주기적으로 디스크에 변경 사항을 flush 할 수 있다면, 요청에 대해 훨씬 더 높은 응답성을 제공하지만, 그 대가로는 서버가 충돌할 경우 마지막 flush 이후의 모든 업데이트가 손실된다는 것이다.
### 영속성 Tradeoff
1. **사용자 세션 상태를 저장하는 경우**
    * 대형 웹사이트의 경우, 많은 사용자들의 임시 정보를 세션 상태에 저장하는데, 이는 웹사이트의 응답성에 영향을 미친다. 
    * 세션 데이터를 잃는 것 보다는 느린 웹사이트가 초래할 불편함이 더 크기 때문에 세션 데이터를 잃는 것은 큰 문제가 아니다.
    * 호출 단이로 영속성 필요성을 지정할 수 있어 중요한 업데이트는 디스크에 flush를 강제할 수 있다.
2. **물리적 장치에서 원격 데이터(telemetric data)를 capturing 하는 경우**
    * 서버가 다운될 때 마지막 업데이트를 놓치는 대가로 더 빠른 속도로 데이터를 capture 하는 것이 더 나을 수 있다.
3. **복제된 데이터**
    * Master-Slave 분산 모델에서 Master를 신속하게 복구할 수 없는 경우, Master가 클라이언트에게 업데이트를 확인하기 전에 일부 복제본이 업데이트를 확인하도록 하여 복제 영속성을 향상시킬 수 있다.
    * 이는 업데이트 속도를 늦추고 Slave에 문제가 생기면 cluster를 사용할 수 없게 만드는 것인데, 영속성이 얼마나 중요한 지에 따라 tradeoff가 발생하는 것이다. 
## Quorums
* **쿼럼(Quorum)** 은 분산 시스템에서 데이터의 일관성과 가용성을 보장하기 위해 사용하는 개념이다.
* 쿼럼은 **읽기 및 쓰기 작업이 충분한 수의 노드에서 확인**되도록 하여 데이터의 일관성을 유지한다.
* 위와 같은 방법으로 네트워크 분할이나 노드 장애 발생 시에도 시스템의 안정성을 높일 수 있다.
### 쿼럼의 기본 개념
* **쓰기 쿼럼 (Write Quorum, W)**
    * 쓰기 작업을 확인해야 하는 최소 노드 수를 의미한다.
    * 쓰기 쿼럼이 충족되어야 해당 쓰기 작업이 성공적으로 완료된 것으로 간주된다.
* **읽기 쿼럼 (Read Quorum, R)**
    * 읽기 작업을 확인해야 하는 최소 노드 수를 의미한다.
    * 읽기 쿼럼이 충족되어야 해당 읽기 작업이 최신 데이터를 반환한다고 보장할 수 있다. 
    * 읽기 쿼럼은 쓰기를 확인하는 노드의 수에 따라 다르기 때문에 쓰기에서 강한 일관성을 가지지 않더라도 강하게 일관된 읽기를 얻을 수 있다.
* **복제 계수 (Replication Factor, N)**
    * 데이터의 복제본 수를 의미한다.
### 쿼럼의 불변식
* 쿼럼을 사용하여 데이터의 일관성을 보장하려면 다음 불변식을 만족해야 한다.    
***R+W>N***    
* 이 불변식은 **읽기와 쓰기 작업이 겹치는 최소한의 노드를 보장**함으로써 일관성을 유지한다. 
* 대부분의 경우 복제 계수 3이 좋은 resilience를 갖추기에 충분하다. 이는 하나의 노드가 실패하더라도 읽기 및 쓰기 쿼럼을 유지할 수 있게 해주고, automatic rebalancing이 있는 경우, cluster가 세 번째 복제본을 생성하는 데 오래 걸리지 않으므로 대체 복제본이 생성되기 전에 두 번째 복제본을 잃을 가능성이 적다. 
* 쓰기 시, 일관성과 가용성을 얼마나 중요시하는 지에 따라 일부 유형의 업데이트에서는 쿼럼이 필요할 수도 있고, 그렇지 않을 수도 있다.
* 속도가 중요하고 오래된 데이터를 용인할 수 있는 읽기에서는 더 적은 노드를 확인해야 한다. 
