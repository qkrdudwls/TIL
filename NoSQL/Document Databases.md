# Document Databases
## What Is a Document Databases?
* 문서 데이터베이스에서는 **데이터의 스키마는 문서마다 다를 수 있지만, 이 문서들은 같은 컬렉션에 속할 수 있다**.
    *  문서는 **XML, JSON, BSON 등 다양한 형식**을 가질 수 있다.
    * 문서는 **Self-describing**하는 성격을 가진다.
    * 데이터베이스는 **계층적 트리 구조**이다.
    * Map, Collection, Scalar 값 등으로 구성된다.
* 문서 데이터베이스는 비어 있는 속성이 없으며, 특정 속성이 없으면 해당 속성이 설정되지 않았거나 문서와 관련이 없다고 가정한다.
* 새로운 속성을 정의하거나 기존 문서를 변경할 필요 없이 문서를 추가할 수 있다.
* **주요 Document Dataabases**: MongoDB, CouchDB, Terrastore, OrientDB, RavenDB, Lotus Notes
## Features (MongoDB)
* 각 MongoDB는 여러 데이터베이스를 가지고 잇으며, 각 데이터베이스는 여러 컬렉션을 가질 수 있다.
    * MongoDB의 인스턴스 = RDBMS의 인스턴스
    * MongoDB의 데이터베이스 = RDBMS의 스키마
    * MongoDB의 컬렉션 = RDBMS의 테이블
* 문서를 저장할 때는 문서가 속할 데이터베이스와 컬렉션을 선택해야 한다.
    * database.collection.insert(document)로 표현
### Consistency
* MongoDB 데이터베이스에서 일관성은 **replica 세트를 사용**하여 구성된다.
* 쓰기 작업이 모든 Slave 또는 지정된 수의 Slave에 복제될 때까지 기다리도록 선택할 수 있다. 
* 각 쓰기 작업은 성공적으로 반환되기 전에 전파되어야 할 서버의 수를 지정할 수 있다.
    * db.runCommand({ getlasterror: 1, w: "majority" }) 명령은 원하는 일관성의 강도를 데이터베이스에 알려준다. 서버가 하나뿐인 경우, w를 majority로 지정하면 하나의 노드만 있기 때문에 쓰기 작업이 즉시 반환된다. Replica 세트에 세 개의 노드가 있고 w를 majority로 지정하면 최소 두 개의 노드에서 쓰기 작업이 완료되어야 성공으로 보고된다. 
    * w값을 증가시키면 더 강한 일관성을 얻을 수 있지만, 더 많은 노드에서 쓰기 작업을 완료해야 하므로 쓰기 성능은 저하된다.
* Replica 세트를 사용하면 **slaveOK를 설정**하여 **Slave에서 읽기를 허용함으로써 읽기 성능을 향상**시킬 수 있다.이때 매개변수는 연결, 데이터베이스, 컬렉션, 또는 개인 작업 별로 설정할 수 있다. 
* 기본적으로 쓰기 작업은 데이터베이스가 수신하면 성공으로 보고되지만, 이를 변경하여 쓰기 작업이 디스크에 동기화되거나 두 개 이상의 Slave에 전파될 때까지 기다리도록 하는 **WriteConcern**을 설정으로써 강한 쓰기 일관성을 달성할 수 있다.
    * WriteConcern을 **REPLICAS_SAFE로 설정하여 특정 쓰기 작업이 Master와 일부 Slave에 기록되도록 보장**할 수 있다. 
### Transactions
* NoSQL에서는 오직 쓰기 작업이 성공하거나 실패할 뿐이다.
* 단일 문서 수준의 트랜잭션을 **Atomic Transactions**이라고 하는데, 여러 작업을 포함하는 트랜잭션은 일반적으로 불가능하지만, RavenDB와 같이 여러 작업에 걸친 트랜잭션을 지원하는 데이터베이스도 있다.
* 기본적으로 모든 쓰기 작업은 성공으로 보고되며, 더 세밀한 쓰기 제어는 WriteConcern 매개변수를 사용하여 가능하다.
    * 다양한 수준의 WriteConcern을 통해 쓰기 작업 중 안전 수준을 선택할 수 있는데, 예를 들어, 로그 항목을 쓸 때는 가장 낮은 안전 수준인 WriteConcern.NONE을 사용할 수 있다.
### Availability
* 문서 데이터베이스는 **Master-Slave 설정을 사용**하여 데이터를 복제함으로써 가용성을 향상시킨다.
* 동일한 데이터가 여러 노드에 존재하기 때문에 주 노드가 다운되더라도 클라이언트는 데이터에 접근할 수 있고, 일반적으로 애플리케이션 코드는 주 노드가 사용 가능한지 여부를 결정할 필요가 없다.
* Replica 세트에서는 두 개 이상의 노드가 비동기 Master-Slave replication에 참여한다.
    * Replica 세트 노드는 스스로 Master, 즉 주 노드를 선출한다. 모든 노드가 동등한 투표권을 가진다고 가정할 때, 다른 서버와 더 가까운 노드, 더  많은 RAM을 가진 노드 등이 우대될 수 있다.
    * 모든 요청은 주 노드로 가며, 데이터는 Slave 노드로 복제된다.
    * 주 노드가 다운되면, replica 세트의 나머지 노드가 투표하여 새로운 주 노드를 선출하고, 모든 향후 요청은 새로운 주 노드로 라우팅된다. 
* 애플리케이션은 주 노드에 쓰거나 읽는다. 연결이 설정되면, replica 세트의 한 노드에만 연결하면 되며, 나머지 노드는 자동으로 이루어진다. 
* 애플리케이션은 통신 실패나 노드 선택 기준을 관리할 필요가 없고, replica 세트를 사용하면 고가용성 문서 데이터베이스를 구축할 수 있다. 
### Query Features
* 문서 데이터베이스는 다양한 쿼리 기능을 제공한다.
    * CouchDB는 뷰를 통해 쿼리를 수행할 수 있는데, 이 뷰는 Materialized Views이거나 Dynamic Views일 수 있다. 
* 문서 데이터베이스의 장점 중 하나는 Key-Value 데이터베이스와 비교할 때, **문서 전체를 key로 검색한 후 내용을 검사하지 않고도 문서 내부 데이터를 쿼리**할 수 있다.
* MongoDB는 JSON을 통해 표현되는 쿼리 언어를 가지고 있으며, $query는 where 절, $orderby는 데이터 정렬, $explain은 쿼리 실행 계획을 보여주는 등 여러 구문을 제공한다. 이러한 구문은 결합하여 MongoDB 쿼리를 생성할 수 있다. 
* **문서가 aggregate된 객체**이므로, 하위 객체의 필드를 사용하여 일치하는 문서를 쿼리하는 것이 매우 간단하고, MongoDB 쿼리는 객체가 단일 문서 내에 임베디드되어 있어 하위 문서를 기반으로 쿼리할 수 있다. 
### Scaling
* 확장성의 개념은 데이터베이스를 더 큰 서버로 단순히 migration 하지 않고 노드를 추가하거나 데이터 저장 방식을 변경하는 것이다. 
* 읽기 부하가 많은 경우, **더 많은 읽기 Slave를 추가하여 모든 읽기 작업을 Slave로 전환**함으로써 확장이 가능하다.
    * 3 노드 replica set cluster에서 읽기 부하가 증가하면, Slave 노드를 더 추가하여 slaveOk 플래그를 사용해 읽기 작업을 실행하도록 설정함으로써 cluster의 읽기 용량을 확장하여 읽기에 대한 수평 확장을 할 수 있다. 
    * 새로운 노드가 추가되면 기존 노드와 동기화되어 replica set의 보조 노드로 합류하고 읽기 요청을 처리하기 시작한다. 이때 다른 노드를 재시작할 필요가 없고, 애플리케이션에도 다운타임이 발생하지 않는다.
* 쓰기 부하를 확장하려면 **데이터 샤딩**을 할 수 있다. 
    * 샤딩에서는 데이터를 특정 필드로 분할하여 다른 Mongo 노드로 이동하고, 샤드는 항상 균형을 유지하기 위해 동적으로 노드 간에 데이터를 이동시킨다. Cluster에 더 많은 노드를 추가하고 쓰기 가능한 노드 수를 증가시켜 수평 확장을 가능하게 한다.
* **Key를 기준으로 데이터를 분할**하면 최적의 쓰기 성능을 위해 샤드 간에 데이터가 균형 있게 분포된다. 
    * 각 샤드는 replica set이 되어 샤드 내에서 더 나은 읽기 성능을 보장할 수 있다.
    * 데이터 이동과 인프라 재구성이 진행되는 동안 애플리케이션에는 다운타임이 발생하지 않지만, 대량의 데이터 이동으로 인해 cluster 성능이 최적화되지 않을 수 있다.
## Suitable Use Cases
### Event Logging
* 애플리케이션은 다양한 이벤트 로깅 요구 사항을 가지고 있고, 기업 내에서는 여러 애플리케이션이 이벤트를 로깅하려고 한다. 문서 데이터베이스는 이러한 다양한 유형의 이벤트를 저장하고 이벤트 저장을 위한 중앙 데이터 저장소로 기능할 수 있다. 
* 특히 이벤트가 capture 하는 데이터 유형이 계속 변경되는 경우에 그러한데, 이벤트는 이벤트가 발생한 애플리케이션 이름이나 order_processed 또는 customer_logged와 같은 이벤트 유형으로 샤딩할 수 있다.
### Content Management Systems, Blogging Platforms
* 문서 데이터베이스는 미리 정의된 스키마가 없고 일반적으로 JSON 문서를 이해하기 때문에 콘텐츠 관리 시스템이나 웹사이트를 게시하고 사용자 댓글, 사용자 등록, 프로필, 웹 문서를 관리하는 애플리케이션에 적합하다.
### Web Analytics or Real-Time Analytics
* 문서 데이터베이스는 실시간 분석 데이터를 저장할 수 있다. 문서의 일부를 업데이트할 수 있기 때문에 페이지 뷰나 고유 방문자를 저장하기가 매우 쉽고, 스키마 변경 없이 새로운 metrics를 쉽게 추가할 수 있다.
### E-Commerce Applications
* E-Commerce 애플리케이션은 종종 제품과 주문에 대한 유연한 스키마가 필요하며, 비싼 데이터베이스 refactoring이나 데이터 migration 없이 데이터 모델을 발전시킬 수 있는 기능이 필요하다.
## When Not to Use
### Complex Transactions Spanning Different Operations
* 단일 문서 간의 atomic operation이 필요하다면 문서 데이터베이스는 적합하지 않을 수 있다.
* RavenDB와 같이 이러한 종류의 작업을 지원하는 일부 문서 데이터베이스도 있다.
### Queries against Varing Aggregate Structure
* 유연한 스키마는 데이터베이스가 스키마에 대한 제약을 강제하지 않음을 의미한다. 
* 데이터는 애플리케이션 entity 형태로 저장되는데, 이러한 entity를 임의로 쿼리해야 하며, 쿼리가 변경될 경우 데이터는 aggregate된 형태로 저장되므로 aggregate 디자인이 계속 변경되는 경우 데이터를 가장 낮은 수준의 세분성으로 저장해야 한다. 
* 즉, 데이터를 정규화해야 한다. 이러한 시나리오에서는 문서 데이터베이스가 적합하지 않을 수 있다. 