# Schema Migrations
## Schemaless
* NoSQL 데이터베이스의 가장 큰 특징 중 하나인 **Schemaless**는 개발자들이 스키마 변경에 대해 걱정하지 않고 도메인 설계에 집중할 수 있게 해주는 기능이다.
* Agile Methods의 부상과 함께 변화하는 요구 사항에 대응할 수 있도록 한다. 
## Schema Changes in RDBMS
* 표준 RDBMS를 이용하여 개발할 때, 객체와 해당 테이블, 그리고 그들의 관계를 고려하여 개발한다.
* RDBMS를 사용할 때 객체에 새로운 항목을 넣는 것과 같이 **객체 모델에 변경이 발생하면, 객체와 데이터베이스 테이블을 모두 변경**해야 한다.
* 스키마 변경 사항을 배포하기 위해 개발 데이터베이스의 모든 변경 사항에 대해 diff 기법을 사용하여 데이터베이스 변경 스크립트를 작성하는데, **배포와 출시 시점에서 migration 스크립트를 작성**하는 방식은 오류가 발생하기 쉽고, Agile Development Methods를 따르지 않는다.
### Migrations for Greenfield Projects
* 데이터 migration 스크립트와 함께 스키마 변경을 동일한 스크립트 파일에 저장할 수 있기 때문에 **개발 중에 데이터베이스 스키마 변경을 스크립트 파일에 저장**하는 것이 배포와 출시 시점에서 스크립트를 작성하는 것보다 더 좋은 방법이다.
* 다른 개발자들과의 통합을 위해서는 변경 스크립트를 프로젝트의 버전 관리 저장소에 저장할 수 있다. 이를 통해 소프트웨어와 데이터베이스의 버전을 동일한 장소에서 추적할 수 있어 **데이터베이스와 애플리케이션 간의 불일치를 제거**할 수 있다.
    * 이를 도와주는 Liquibase, MyBatis Migrator, DBMaintain과 같은 많은 도구들이 있다. 
### Migration in Legacy Projects
* 기존 애플리케이션이 prodcution 중일 때, migration은 **기존 데이터베이스를 가져와 구조를 스크립트로 추출**하고, **모든 데이터베이스 코드와 참조 데이터를 포함**시켜 이를 프로젝트의 기준으로 사용하는데, 이때 트랜잭션 데이터가 포함되지 않아야 한다. 
* Migration의 주요 측면 중 하나는 **데이터베이스 스키마의 하위 호환성을 유지**하는 것이다.
    * 하위 호환성을 유지하기 위해서는 변경 사항에 대한 **전환 단계**를 유지해야 한다. 
    * 전환 단계 동안, 이전 스키마와 새로운 스키마를 병행하여 유지하며, 데이터베이스를 사용하는 모든 애플리케이션이 접근할 수 있게 한다. 
    * 이를 위해 triggers, Views, Virtual Columms와 같은 **scaffolding code**를 도입하여 다른 애플리케이션이 코드 변경 없이 데이터베이스 스키마와 필요한 데이터에 접근할 수 있도록 한다. 
* 대규모 데이터베이스에서 스키마 migration을 수행하는 것은 매우 어려운데, 애플리케이션이 데이터베이스를 게속 사용 가능하게 하는 경우, 대규모 데이터 이동 및 구조 변경은 일반적으로 locks를 생성하기 때문이다. 
## Schema Changes in a NoSQL Data Store
* Schemaless 접근 방식은 **entity 별 스키마 변경의 유연성**을 목표로 한다.
* NoSQL 데이터베이스를 개발할 때, 스키마를 생각할 필요가 없는 경우가 있지만, column-familly 이름, 행, 열, column 순서, key 할당 방식 및 객체 내 데이터 구조와 같은 측면들을 고려해야 한다. 
* NoSQL 데이터베이스는 완전한 schemaless는 아닌데, 애플리케이션을 refactoring 할 때 데이터 스키마를 고려해야 한다. 
    * 데이터벵이스는 데이터를 스키마에 상관없이 저장하지만, **데이터 stream이 데이터베이스에서 읽힐 때 애플리케이션이 이를 parsing** 해야 하므로 **애플리케이션이 해당 스키마를 정의**해야 한다.
    * 애플리케이션은 데이터베이스에 저장할 데이터를 생성해야 하는데, 애플리케이션이 데이터베이스의 데이터를 parsing 할 수 없다면, RDBMS 데이터베이스에 오류가 발생하는 대신 애플리케이션에서 **스키마 불일치 오류**가 발생하게 된다.
* 기존 production 데이터를 처리할 때는 주의가 필요하다.
### Incremental Migration
* 애플리케이션에서 스키마가 변경될 때, 기존 데이터를 새 스키마로 모두 변환해야 하는데, 이 작업은 데이터 크기에 따라 비용이 많이 들 수 있다는 문제점이 있다.
* 시간이 지남에 따라 데이터를 migration 할 수 있는 **Incremental Migration** 기법을 사용할 수 있다.
    * 스키마가 변경되기 전에 데이터가 새로운 코드로 parsing 될 수 있도록 하고, 저장될 때 새로운 스키마로 다시 저장되도록 한다.
* Incremental migration을 사용할 때 애플리케이션 쪽에서 여러 버전의 객체가 존재할 수 있으며, 이 객체들은 **기존의 스키마를 새로운 스키마로 변환**할 수 있다. 
    * 객체를 다시 저장할 때는 새로운 객체를 사용하여 저장한다.
* Incremental migration 기법은 새로운 변경 사항이 도입되면서도 기존의 변경 사항이 제거되지 않을 때 객체 설계를 복잡한게 만든다. 
    * 이 변경 배포와 데이터베이스의 마지막 객체가 새로운 스키마로 migration 되는 사이의 기간을 **전환 기간**이라 하며, 이 기간을 가능한 짧게 유지하고 최소한의 범위로 설정하는 것이 좋다. 
* Incremental migration 기법은 **데이터에 schema_version 필드를 추가**하여 **애플리케이션이 데이터를 객체로 parsing 하기 위해 올바른 코드를 선택하도록 구현**할 수도 있다.
    * 데이터를 저장할 때 최신 버전으로 migration 하고 schema_version을 업데이트하여 이를 반영한다.
    * 도메인과 데이터베이스 사이에 적절한 **translation layer**를 두는 것이 중요하다. 이렇게 하면 스키마 변경 시 여러 버전의 스키마 관리는 translation layer로 제한되고 애플리케이션 전체로 퍼지지 않는다.
### Migration in Graph Databases
* Codebase에서 그래프 데이터베이스의 edge의 유형을 변경하면 데이터베이스를 탐색할 수 없게 되어 사용할 수 없게 된다.
* 이 문제점을 해결하기 위해 모든 edge를 탐색하고 각 edge의 유형을 변경할 수 있는데, 이 작업은 비용이 많이 들며 데이터베이스의 모든 edge를 migration 하기 위한 코드를 작성해야 한다.
* 호환성을 유지해야 하거나 그래프 전체를 한 번에 변경하고 싶지 않다면, 노드 간에 **새로운 edge를 생성**할 수 있다. 이 기법은 대규모 데이터베이스에서 고가용성을 유지하려고 할 때 유용할 수 있다.
* 노드의 데이터를 변경해야 하는 경우, 새로우 데이터는 기존 노드 데이터에서 파생되거나 다른 source에서 가져올 수 있다.
    * 데이터의 source에서 제공하는 인덱스를 사용하여 모든 노드를 가져오고 각 노드에 관련 데이터를 작성함으로써 migration을 수행할 수 있다.
### Changing Aggregate Structure
* 큰 객체를 독립적으로 저장된 작은 객체로 분할하여 스키마 디자인을 변경해야 하는 경우가 있다.
    * 모든 고객 주문을 포함하는 고객 aggregate가 있다고 가정하고, 고객과 각 주문을 서로 다른 aggregate 단위로 분리하고 싶다면, 이 작업을 진행해야 한다.
* 백그라운드에서 실행되는 코드는 한 번에 하나의 aggregate를 읽고, 필요한 변경을 가하고, 데이터를 다른 aggregate에 저장할 수 있다.
* 한 번에 하나의 aggregate에 대해 작업하는 것의 장점은 애플리케이션의 데이터 가용성을 방해하지 않는다는 점이다. 