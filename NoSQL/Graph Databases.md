# Graph Databases
## What Is a Graph Database?
* 그래프 데이터베이스는 **entity와 이들 entity 간의 관계를 저장**한다.
    * Entity는 노드라고도 하며, **속성**(properties)을 가지고 있다.
    * 노드는 애플리케이션에서 **객체의 인스턴스**라고 생각할 수 있다.
* 관계는 **edge**라고 하며, edge 또한 속성을 가질 수 있다.
    * Edge는 **방향성**을 가지며, 노드는 edge에 따라 조직된다. 
* 그래프가 만들어지면 다양한 방식으로 쿼리할 수 있는데, 그래프 쿼리는 그래프를 **순회**함으로써 이루어진다.
* 그래프 데이터베이스의 장점은 **노드나 edge를 변경하지 않고도 순회 요구 사항을 변경할 수 있다**는 점이다.
* **노드 간의 관계는 데이터베이스에 실제 관계로 저장**되어 있기 때문에 관계 탐색 시 이러한 관계를 다시 계산할 필요가 없다. 따라서 그래프 데이터베이스는 탐색 작업에서 RDBMS보다 훨씬 더 빠르게 작동할 수 있다. 
    * RDBMS에 그래프와 같은 구조를 저장할 때는 일반적으로 단일 유형 관계를 저장하는데, 새로운 관계를 추가하려면 많은 스키마 변경과 데이터 이동이 필요하다. 
* 노드는 여려 유형의 관계를 가질 수 있는데, 도메인 entity 간의 관계와 카테고리, 경로, time-trees, 공간 인덱싱을 위한 quad-trees, 정렬된 접근을 위한 linked list와 같은 보조 관계를 모두 표현할 수 있다. 노드가 가질 수 있는 관계의 수와 종류에 제한이 없기 때문에 모두 동일한 그래프 데이터베이스로 표현할 수 있다.
* 그래프 데이터베이스에는 Neo4J, Infinite Graph, OrientDB, FlockDB 등 많은 그래프 데이터베이스가 있다.
## Features
* 관계를 생성할 때는 **관계의 방향성이 중요**하기 때문에 노드 간의 관계를 고려해야 한다.
* 그래프 데이터베이스의 대부분의 가치는 관계에서 파생되며, 관계는 단순히 유형, 시작 노드, 끝 노드 뿐만 아니라 속성을 가질 수도 있다.
    * 관계의 속성은 그래프를 쿼리하는 데 사용할 수 있다.
### Consistency
* 그래프 데이터베이스는 연결된 노드에서 작동하므로 **대부분의 그래프 데이터베이스는 노드를 서로 다른 서버에 분산하는 것을 지원하지 않는다.**
    * Infinite Graph와 같이 cluster 서버 간에 노드를 분산하는 것을 지원하는 데이터베이스도 존재한다. 
* 단일 서버 내에서는 데이터가 항상 일관성을 유지하는 데, **Neo4J는 ACID를 완벽히 준수**한다. 
    * Neo4J를 cluster에서 실행할 때 Master에 대한 쓰기는 Slave와 동기화되고, Slave는 항상 읽기 가능한 상태를 유지한다. 
    * Slave에 대한 쓰기는 허용되며 Master와 즉시 동기화되고, 이때 다른 Slave는 데이터를 Master에서 전달 받기를 기다려야 한다.
* 그래프 데이터베이스는 **트랜잭션**을 통해 일관성을 보장한다. 시작 노드와 끝 노드가 항상 존재해야 하며, 관계가 없는 노드만 삭제할 수 있다.
### Transactions
* Neo4J는 ACID를 준수하기 때문에 노드를 변경하거나 기존 노드에 관계를 추가하기 전에 트랜잭션을 시작해야 한다.
    * 트랜잭션으로 작업을 wrapping 하지 않으면 NotInTransactionException이 발생한다.
    * 읽기 작업은 트랜잭션을 시작하지 않고 수행할 수 있다.
* 트랜잭션 생성 후, 트랜잭션을 성공으로 표시하지 않으면 Neo4J는 실패한 것으로 간주한다.
* 트랜잭션 관리 방법은 RDBMS에서의 표준 트랜잭션 관리와는 다른데, 성공으로 표시하는 것 만으로는 데이터를 데이터베이스에 커밋하지 않는다.
### Availability
* Neo4J는 1.8 버전부터 **복제된 Slave를 제공하여 고가용성을 보장**한다.
    * 이러한 Slave는 쓰기도 처리할 수 있으며, Slave에 대한 쓰기는 현재 Master와 동기화되며, 먼저 Master에 커밋된 후 Slave에 커밋된다. 이때, 다른 Slave는 업데이트를 나중에 받는다.
* Neo4J는 Apache ZooKeeper를 사용하여 각 Slave 노드와 현재 Master 노드에 저장된 마지막 트랜잭션 ID를 추적한다. 
    * 서버가 시작되면 ZooKeeper와 통신하여 어느 서버가 Master인지 확인하는데, cluster에 첫 번째로 조인하는 서버는 Master가 되고, Master가 다운되면 cluster 는 사용 가능한 노드 중에서 Master를 선출하여 고가용성을 제공한다.
### Query Features
* 그래프 데이터베이스는 Gremlin과 같은 쿼리 언어를 제공한다.
    * Gremlin은 그래프를 탐색하는 도메인 특화 언어로, Blueprints 속성 그래프를 구현한 모든 그래프 데이터베이스를 탐색할 수 있다. 
* Neo4J는 그래프를 쿼리하기 위한 Cyper 쿼리 언어를 제공한다. 쿼리 언어 외에도 Neo4J는 노드의 속성을 쿼리하거나, 그래프를 탐색하거나, 언어 바인딩을 사용하여 노드의 관계를 탐색할 수 있도록 한다.
* 노드의 속성은 **인덱싱 서비스를 사용**하여 인덱싱할 수 있다.
    * Neo4J는 인덱싱 서비스로 Lucene을 사용한다. 
* 관계의 속성도 인덱싱할 수 있어, 값을 통해 노드나 관계를 찾을 수 있다.
* 노드를 인덱스에 추가하는 작업은 트랜잭션 내에서 수행된다.
* 관계를 쿼리할 때 **방향 필터**를 적용할 수 있다.
* 그래프 데이터베이스는 **임의의 깊이에서 그래프를 탐색하고, 탐색을 시작할 노드를 지정할 때 강력**하다. 
    * 시작 노드에서 여러 레벨 아래로 관련된 노드를 찾고자 할 때 유용하다. 
* 그래프 데이터베이스는 **두 노드 간의 경로를 찾을 때 유용**하다. 두 노드 간에 여러 경로가 있는지, 모든 경로 탐색 또는 최단 경로를 탐색할 수 있고, Dijkstra 알고리즘과 같이 여러 알고리즘을 적용할 수 있다. 
* Neo4J가 제공하는 Cyper는 쿼리를 시작할 노드를 필요로 한다.
    * 시작 노드는 노드 ID, 노드 ID 목록 또는 인덱스 조회를 통해 식별될 수 있다. 
* Cypher는 관계에서 패턴을 매칭하기 위해 **MATCH** 키워드를 사용하고, 노드 또는 관계의 속성을 필터링하기 위해 **WHERE** 키워드를 사용한다. **RETURN** 키워드는 쿼리 결과로 반환될 노드, 관계 또는 노드나 관계의 필드 항목을 지정한다. 또한, Cypher는 또한 데이터를 정렬(**ORDER**), 집계(**AGGREGATE**), 건너뛰기(**SKIP**), 및 제한(**LIMIT**)하는 메서드를 제공한다. 
### Scaling
* NoSQL 데이터베이스에서 일반적으로 사용하는 확장 기술인 **샤딩**은 그래프 데이터베이스에 적용하기 어려운데, 그래프 데이터베이스는 **관계 지향적**이기 때문이다.
* 주어진 노드는 다른 노드와 관련될 수 있으므로 관련된 노드를 서버에 저장하는 것이 그래프 탐색에 좋다. 노드가 서로 다른 서버에 있다면 그래프 탐색 성능이 좋지 않은데, 이러한 한계가 있어도 그래프 데이터베이스를 확장할 수 있는 기술이 있다.
#### 그래프 데이터베이스를 확장하는 방법
1. 데이터 세트의 노드와 관계가 메모리에 모두 포함될 수 있도록 **충분한 RAM을 추가**한다.
    * 작업하고자 하는 데이터 세트가 현실적인 양의 RAM에 맞을 때만 유용하다. 
2. 데이터베이스의 읽기 확장을 개선하기 위해 **읽기 전용 액세스를 가진 Slave를 추가**하고, 모든 쓰기는 Master로 향하게 할 수 있다. 
    * 이 패턴은 MySQL clsuter에서 입증된 기술로, 데이터 세트가 단일 서버의 RAM에 맞지 않을 만큼 크지만, 여러 서버에 복제될 만큼 작을 때 유용하다. 
    * Slave는 Master가 되지 않도록 설정하여 항상 읽기 전용으로 유지할 수 있고, 이를 통해 가용성과 읽기 확장을 제공할 수 있다.
3. 데이터 세트의 크기가 복제를 불가능하게 만들 때, 애플리케이션 측에서 **도메인 특화 지식을 사용하여 데이터를 샤딩**할 수 있다.
## Suitable Use Cases
### Connected Data
* 그래프 데이터베이스는 소셜 네트워크에서 매우 효과적으로 배포되고 사용될 수 있다.
* **Link가 풍부한 도메인**은 그래프 데이터베이스에 적합한데, 서로 다른 도메인에서 도메인 entity 간의 관계를 데이터베이스에 보유하고 있는 경우, 도메인 간의 관계를 탐색할 수 있는 기능을 제공하여 관계를 더 가치 있게 만들 수 있다.
### Routing, Dispatch and Location-Based Services
* 배송이 필요한 모든 위치 또는 주소는 노드이며, 배달원이 배송해야 하는 모든 노드는 노드의 그래프로 모델링할 수 있다. **노드 간의 관계는 거리를 속성으로** 가질 수 있으므로 상품을 효율적으로 배달할 수 있다.
* 거리 및 위치 속성은 흥미로운 장소의 그래프에도 사용될 수 있어서 애플리케이션이 근처의 좋은 식당이나 엔터테인먼트 옵션을 추천할 수 있도록 한다. 또한, 판매 지점을 노드로 만들어 사용자가 노드 근처에 있을 때 알림을 제공하여 위치 기반 서비스를 제공할 수 있다.
### Recommendation Engines
* 시스템에 노드와 관계가 생성됨에 따라 "당신의 친구들도 이 제품을 구매했습니다" 또는 "이 항목을 청구할 때 이러한 다른 항목도 자주 청구됩니다"와 같은 추천을 할 수 있다.
* 그래프 데이터베이스를 추천 엔진에 사용할 경우의 부작용은 **데이터 크기가 증가함에 따라 추천을 빠르게 만들 수 있는 노드와 관계의 수가 급격히 증가**한다는 것이다.
## When Not to Use
* 모든 entity 또는 entity의 하위 집합을 업데이트해야 하는 경우 그래프 데이터베이스는 최적이 아닐 수 있다.
* 모든 노드에서 속성을 변경하는 것은 간단하지 않은데, 데이터 모델이 문제 도메인에 적합하더라도 일부 데이터베이스는 많은 데이터를 처리할 수 없으며, 특히 전체 그래프를 포함하는 전역 그래프 작업에서는 더욱 그렇다.