# Version Stamps
* 트랜잭션을 사용하지 않는 aggregate 지향 데이터베이스는 aggregate 내에서 업데이트를 지원하고, aggregate가 자연스럽게 업데이트 단위를 형성하도록 설계되어 있기 때문에 일관성을 유지할 수 있다.
* 트랜잭션 내에서도 사람의 개입이 필요한 업데이트를 처리해야 하는데, 이는 트랜잭션을 오래 열어두어야 하기 때문에 일반적으로 트랜잭션 내에서 실행할 수 없어 **버전 스탬프**를 사용한다.
* 버전 스탬프는 단일 서버 분산 모델에서 벗어나 다른 상황에서도 유용하게 사용된다.
## Business and System Transactions
* **'트랜잭션 없이도 업데이트 일관성을 지원해야 한다'**: 트랜잭션 데이터베이스를 사용하는 시스템에서도 해당하는 사항
* 실제 비즈니스 프로세스. 사용자가 특정 작업을 완료하는 일련의 상호 작용을 포함하는 **비즈니스 트랜잭션**의 모든 과정은 데이터베이스가 제공하는 **시스템 트랜잭션** 내에서 발생하지 않는 경우가 많다.
* 일반적으로 애플리케이션은 사용자외의 상호 작용이 끝날 땜에만 시스템 트랜잭션을 시작하여 잠금이 짧은 시간 동안만 유지되도록 하는데, 이때 NoSQL 시스템에서는 **Optimistic Offline Lock**이 유용하게 사용된다.
  * **낙관적 오프라인 잠금(Optimistic Offline Lock)**: 조건부 업데이트의 한 형태로, 비즈니스 트랜잭션에 의존하는 클라이언트 작업 정보를 다시 읽고, 사용자에게 표시된 이후로 변경되지 않았는지 확인하는 것.
* 이 과정에서 사용되는 방법은 데이터베이스의 레코드에 버전 스탬프를 포함하는 것으로, 데이터를 읽을 때 버전 스탬프를 기록해 두고, 데이터를 쓸 때 버전이 변경되었는지 확인할 수 있다.
### 버전 스탬프를 구성하는 방법
**1. 카운터 사용**
* 리소를 업데이트할 때마다 증가
* 한 버전이 다른 버전보다 최신인 지 쉽게 알 수 있어 유용하다.
* 서버는 카운터 값을 생성해야 하고, 중복되지 않도록 단일 Master가 필요하다.    
**2. GUID 생성**
* GUID: 임의의 큰 숫자로, 고유성이 보장
* 날짜, 하드웨어 정보 및 기타 무작위 소스를 조합하여 생성한다.
* 누구나 생성할 수 있고, 중복되지 않는다.
* 크기가 크고 버전이 최신인 지를 직접 비교할 수 없다.     
**3. 리소스의 내용을 해시**
* 충분히 큰 해시 키 크기를 사용하면 내용 해시(Content Hash)는 GUID처럼 유일하고, 누구나 생성할 수 있다.
* 동일한 리소스 데이터에 대해 동일한 내용 해시를 생성한다.
* GUID와 마찬가지로 최신 버전인 지 직접 확인이 불가능하고, 길이가 길어질 수 있다.    
**4. 마지막 업데이트의 타임 스탬프를 사용**
* 카운터와 마찬가지로 짧고 최근 버전인 지 직접 비교할 수 있으며, 단일 Master가 필요 없다.
* 여러 기기가 타임 스탬프를 생성할 수 있지만, 시계가 동기화 되어 있어야 제대로 작동한다.
* 시계가 잘못된 노드는 데이터 손상을 일으킬 수 있고 타임 스탬프의 정밀도가 너무 낮으면 중복이 발생할 수 있다.     
**5. 여러 버전 스탬프 체계를 혼합**
* ex. CouchDB는 카운터와 내용 해시 조합을 사용하여 P2P replication을 사용할 때도 버전이 최신인 지를 비교할 수 있게 한다.
## Version Stamps and Multiple Nodes
* 기본적인 버전 스탬프는 단일 서버 또는 Master-Slave replication과 같이 하나의 authoritative 데이터가 있을 때 잘 작동한다.
  * 버전 스탬프는 Master에 의해 제어되고, Slave는 Master의 버전 스탬프를 따른다. 
* Peer-to-Peer replication 모델에서는 버전 스템프를 설정할 수 있는 단일 데이터가 없기 때문에 버전 스탬프 시스템을 강화해야 한다. 
* Peer-to-Peer NoSQL 시스템에서 일반적으로 사용하는 방법은 **벡터 스탬프**라는 특수한 형태의 버전 스탬프를 사용하는 것이다.
### Vector Stamp
* 벡터 스탬프는 각 노드에 대한 카운터 집합으로, 각 노드는 내부 업데이트를 할 때마다 자신의 카운터를 업데이트하고, **두 노드가 통신할 때마다 벡터 스탬프를 동기화**한다.
* 벡터 스탬프를 사용하면 하나의 버전 스탬프가 다른 것보다 최신인지 알 수 있다.
* 최신 스탬프는 모든 카운터가 이전 스탬프의 카운터보다 크거나 같아야 하는데, 만약 두 스탬프의 카운터가 서로 다를 때, 예를 들어 [A: 1, B: 5, C: 2], [A: 3, B: 5, C: 1]일 때는 쓰기-쓰기 충돌이 발생한다.
* 벡터에 **누락된 값이 있을 때에는 0으로 취급**함으로써 새로운 노드를 쉽게 추가할 수 있도록 하여 기존 버전 스탬프를 무효화하지 않는다.
* **벡터 스탬프는 불일치를 감지할 뿐 해결하지는 않는다.** 
