# Beyond NoSQL
## File Systems
* 파일 시스템은 **어디에서나 사용**된다.
* 파일 시스템은 **내부 구조를 드러내지 않고 계층적 key를 가진 Key-Value Database와 유사**하다. 또한 단순한 파일 잠금 외에는 동시성 제어를 거의 제공하지 않는데, 이는 NoSQL이 단일 aggregate 내에서만 잠금을 제공하는 방식과 유사하다.
* 파일 시스템은 단순하고 널리 구현된다는 장점이 있다.
    * 비디오 오디오와 같은 거대한 entity를 잘 처리할 수 있는데, 종종 데이터베이스는 파일에 저장된 미디어 데이터를 인덱싱 하는 데 사용된다.
    * 파일은 스트리밍과 같은 **순차적 액세스에도 매우 적합**하며, 이는 **append-only 데이터에 유용**할 수 있다.
* Cluster 환경에 대한 관심이 높아지면서 **분산 파일 시스템**이 등장했다. Google 파일 시스템 및 Hadoop과 같은 기술은 파일의 복제를 지원하는데, 이때 map-reduce는 cluster 시스템에서 대용량 파일을 조작하는 것과 관련이 있다. 분산 파일 시스템은 **대형 파일을 여러 노드에서 처리할 수 있도록 자동으로 분할하는 도구를 포함**하는데, 실제로 NoSQL에 진입하는 일반적인 경로는 Hadoop을 사용해온 조직에서 시작된다.
* 파일 시스템은 **큰 덩어리로 처리할 수 있는 상대적으로 적은 수의 대용량 파일에 가장 적합**하며, **스트리밍 스타일이 바람직**하다. 
* 작은 파일이 대량으로 존재할 경우 성능이 저하되며, 이때는 데이터베이스가 더 효율적이다. 또한 파일은 Solr과 같은 추가 인덱싱 도구 없이 쿼리를 지원하지 않는다.
## Event Sourcing
* **Event Sourcing**은 현재 애플리케이션 상태 자체를 유지하는 대신, 모든 변경 사항을 지속적인 상태로 유지하는 데 중점을 둔 **지속성에 대한 접근 방식**이다.
* Event Sourcing 시스템에서는 **시스템의 상태 변화를 일으킨 모든 이벤트를 이벤트 로그에 저장**한다. 애플리케이션 상태는 이 이벤트 로그에서 완전히 도출될 수 있고, 언제든지 애플리케이션 상태를 버리고 이벤트 로그에서 다시 생성할 수 있다.
* 이론적으로 이벤트 로그만 있으면 언제든지 이벤트 로그를 재생하여 애플리케이션 상태를 재현할 수 있지만, 이러한 방식을 실제로 구현하면 너무 느릴 수 있다. 따라서 **애플리케이션 상태를 스냅샷 형태로 저장하고 다시 생성할 수 있는 기능을 제공**하는 것이 좋다.
    * 스냅샷은 **상태의 신속한 복구를 위해 최적화된 메모리 이미지를 저장하기 위한 것**으로, 최적한 도구이기 때문에 데이터에 대한 권한으로서 이벤트 로그보다 우선시되어서는 안된다.
    * 스냅샷을 얼마나 자주 찍을지는 시스템의 가동 시간 요구 사항에 따라 다르다.
    * 스냅샷은 완전히 최신일 필요는 없는데, 최신 스냅샷을 로드하고 스냅샷이 찍힌 이후 처리된 모든 이벤트를 재생하여 메모리를 복구할 수 있다.
    * 애플리케이션 상태의 모든 변경 사항에 대한 전체 기록을 얻으려면, 애플리케이션의 시작 시점부터 이벤트 로그를 유지해야 하는데, 많은 경우 이러한 장기적인 기록이 필요하지 않을 수 있다. 이 경우 오래된 이벤트는 스냅샷에 이용하여 저장하고, 이후의 이벤트만 이벤트 로그로 사용하면 된다.
* Event Sourcing을 사용하면, **이벤트를 여러 시스템에 broadcast 하여 각각 다른 목적을 위한 애플리케이션 상태를 생성**할 수 있다.
* Event Sourcing은 **과거 정보를 분석**하는 데에도 효과적이다. 이벤트 로그에 있는 과거 상태를 복제할 수 있기 때문이다. 가상의 이벤트를 도입하여 대안 시나리오를 쉽게 조사할 수도 있다.
* Event Sourcing은 **모든 상태 변경이 이벤트로 capture 되고 저장되도록 해야 한다**는 점인데, 일부 아키텍처 및 도구는 이를 불편하게 만들 수 있다. 외부 시스템과의 협업 시에는 event sourcing을 고려해야 하며, 애플리케이션 상태를 재구성하기 위해 이벤트를 재생할 때 외부 부작용을 주의해야 한다.
## Memory Image
* Event Sourcing의 결과 중 하나는 **이벤트 로그가 definitive persistent memory이 된다**는 점이다.
    * 애플리케이션 상태 자제가 지속될 필요는 없다. 이는 애플리케이션 상태를 메모리에만 유지하면서 메모리 내 데이터 구조만 사용하는 옵션을 제시하는데, 작업 데이터를 모두 메모리에 저장하면 이벤트를 처리할 때 디스크 I/O를 처리할 필요가 없어 성능 이점을 제공한다.
    * 디스크와 메모리 간의 데이터 구조 매핑을 수행할 필요가 없으므로 프로그래밍이 간단해진다.
* 한계점은 **필요한 모든 데이터를 메모리에 저장할 수 있어야 한다**는 점인데, 이는 점점 더 실현 가능해지고 있다.
* **동시성을 처리하기 위한 메커니즘**이 필요햐다.
    1. Clojure 언어와 같은 **transactional memory system**을 사용
    2. 모든 입력 처리를 **단일 스레드**에서 수행
* **In-memory와 persistent data 간의 분리를 해제**하면 오류 처리 방식에도 영향을 미친다. 일반적인 접근 방식은 모델을 업데이트하고 오류가 발생할 경우 **변경 사항을 roll back** 하는 것이다. 
## Version Control
* 버전 관리 시스템은 **파일 시스템 위에 구축되며, 따라서 파일 시스템과 같은 데이터 저장의 제한 사항을 공유**한다.
* 이러한 시스템은 애플리케이션 데이터 저장을 위해 설계되지 않았기 때문에, 해당 context에서 사용하기가 불편하다.
* Timeline 기능이 유용한 시나리오에서는 고려할 가치가 있다 .
## XML Databases
* XML 데이터베이스는 **XML과 호환되는 데이터 모델**로 문서를 저장하고, 다양한 XML 기술을 사용하여 문서를 조작할 수 있는 문서 데이터베이스로 생각할 수 있다.
* 다양한 형태의 **XML 스키마 정의(DTD, XML Schema, RelaxNG)를 사용하여 문서 형식을 검사**하고, **XPath 및 XQuery를 사용하여 질의를 수행**하며, **XSLT를 사용하여 변환을 수행**할 수 있다.
* 관계형 데이터베이스는 XML을 수용하고 **XML 기능을 관계형 기능과 혼합**하여 XML 문서를 열로 내장하고 SQL과 XML 질의 언어를 혼합하는 방법을 제공한다.
## Object Databases
* 객체 지향 프로그래밍의 인기가 상승하면서 객체 지향 데이터베이스에 대한 관심이 급증했다. 여기서 초점은 **메모리 내 데이터 구조를 관계형 테이블에 매핑하는 복잡성**이었다. 객체 지향 데이터베이스의 개념은 이러한 **복잡성을 피하는 것**이다.
* 객체 데이터베이스와 관련된 중요한 문제는 **데이터 구조가 변경될 때 어떻게 migration 할 것인지** 이다. 여기서 **영구 저장소와 메모리 내 구조 간의 밀접한 연관성이 문제**가 될 수 있다. 
