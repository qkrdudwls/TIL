# Map-Reduce 
* Google에서 개발한 프로그래밍 모델 
* Cluster에서 여러 대의 머신을 활용하여 데이터를 최대한 동일한 머신에서 처리하면서 계산을 조직하는 방법
* 데이터의 **병렬 처리**와 **분산 처리**를 쉽게 할 수 있도록 설계되었으며, 특히 대량의 데이터를 효율적으로 처리하는 데 강력한 성능 발휘 
## Basic Map-Reduce
* **Map**: 입력으로 단일 aggregate를 받아 key-value 쌍의 집합을 출력하는 함수
    * Map 함수는 단일 aggregate의 데이터에서만 작동한다. 
    * Map은 한 번에 단일 레코드를 읽어 독립적이기 때문에 병렬화가 가능하다.
* **Reduce**: 동일한 key를 가진 모든 값들을 처리하여 단일 결과를 반한하는 함수
    * 동일한 key를 가진 여러 map 출력 값을 결합 
* **Map-Reduce 프레임워크**
    * 각 노드에서 효율적인 map을 생성하고 각 입력을 자유롭게 map에 할당하여 데이터 접근의 병렬성과 지역성을 크게 증가시킨다.
    * 올바른 노드에서 map 작업을 수행하고, 데이터를 reduce 함수로 이동시킨다. 
    * Reduce 함수를 쉽게 작성할 수 있도록 단일 key에 대한 모든 값을 수집하고, 해당 key와 모든 값의 컬렉션을 사용하여 reduce 함수를 한 번 호출한다. 
## Partitioning and Combining
### 기본 형태에서 병렬성을 증가시키고 데이터 전송량을 줄이는 방법
* **Mapper의 출력을 분할**
    * Mapper의 결과는 각 처리 노드에서 key를 기준으로 분할
    * 프레임워크는 각 파티션에 대한 모든 노드의 데이터를 가져와 단일 그룹으로 결합하고, 이를 reducer로 보낸다. 여러 reducer는 파티션에 대해 병렬로 작동하고, 최종 결과는 함께 병합된다. 이를 **shuffling**이라고 하며, 파티션은 **bucket** 또는 **region**이라고 한다.
* **Combinable reducer**
    * Combiner 함수는 **동일한 key에 대한 모든 데이터를 단일 값으로 결합**하여 노드 간 이동하는 데이터 양을 줄인다.
    * 본질적으로는 reduce 함수와 같다.
    * 이 기능이 작동하려면 reduce 함수는 입력과 출력이 일치해야 하는데, 이러한 함수를 **Combinable reducer**라고 한다.
    * 모든 reduce 함수가 결합 가능한 것은 아니다.
* Map-Reduce 프레임워크는 combinable reducer를 사용할 때, 서로 다른 파티션을 줄이기 위해 병렬로 안전하게 실행할 수 있을 뿐만 아니라 서로 다른 시간과 장소에서 동일한 파티션을 줄이기 위해 직렬로 실행할 수도 있다.
* Combinable 하지 않은 reducer를 사용하려면, 처리 과정을 파이프라인 map-reduce 단계로 나누어야 한다. 
## Composing Map-Reduce Calculations
* Map 단계와 reduce 단계 제약 내에서 잘 작동할 수 있도록 프로그램을 구조화하는 방식에 대해 다르게 생각해야 한다.
* 제한 사항 중 하나는 연산을 reduce 작업의 개념에 잘 맞도록 구조화해야 한다는 것이다.
* Map-Reduce 연산이 복잡해짐에 따라, 파이프와 필터 접근 방식을 사용하면 단계를 나누는 것이 유용하다. 이때, 각 단계의 출력이 다음 단계의 입력으로 사용된다.
### Incremental Map-Reduce
* 많은 Map-Reduce 연산은 cluster 하드웨어를 사용해도 시간이 오래 걸릴 수 있으며, 새로운 데이터가 계속 들어옴에 따라 출력을 최신 상태로 유지하기 위해 연산을 다시 실행해야 한다. 매번 처음부터 다시 시작하는 것은 시간이 너무 오래 걸리기 때문에, 최소한의 연산 만으로 출력을 업데이트할 수 있도록 map-redcue 연산을 구성하는 것이 유용하다. 
* Map 단계에서는 입력 데이터가 변경될 때만 mapper를 다시 실행하면 되는데, map은 **서로 독립적이기 때문에 incremental update가 가능**하다.
* Reduce 단계는 많은 map의 출력을 결합하므로, map 출력의 변경이 새로운 reduce를 trigger 할 수 있어 더 복잡하지만, reduce 단계를 병렬화하면 계산량을 줄일 수 있다. 
* 데이터 reduction을 위해 분할한다면, 변경되지 않은 파티션은 다시 reduce 할 필요가 없고, combiner 단계가 있다면, 소스 데이터가 변경되지 않는 한 combiner를 다시 실행할 필요가 없다.
* Reducer가 combinable 하다면, 새 레코드만 추가되고 이전 레코드는 변경되거나 삭제되지 않는 경우, 기존 결과와 새로운 추가 항목 만으로 reduce를 실행할 수 있다. 
* 업데이트 및 삭제와 같은 변경이 있는 경우, reduce 연산을 단계 별로 나누고 입력이 변경된 단계만 다시 계산함으로써 일부 재계산을 피할 수 있다.
* Map-Reduce 계산 결과가 global 하게 사용되는 경우, 이를 **Materialized views**로 저장할 수 있다. 